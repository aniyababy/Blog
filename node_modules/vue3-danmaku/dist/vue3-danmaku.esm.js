import { computed, defineComponent, ref, reactive, onMounted, onBeforeUnmount, nextTick, createApp, h, openBlock, createElementBlock, createElementVNode, normalizeClass, renderSlot } from 'vue';

function useModelWrapper(props, emit, name = 'modelValue', translater) {
    return computed({
        get: () => props[name],
        set: (value) => {
            emit(`update:${name}`, translater ? translater(value) : value);
        },
    });
}

var script = defineComponent({
    name: 'vue3-danmaku',
    components: {},
    props: {
        /**
         * 弹幕列表数据
         */
        danmus: {
            type: Array,
            required: true,
            default: () => [],
        },
        /**
         * 轨道数量，0为最大轨道数量（撑满容器）
         */
        channels: {
            type: Number,
            default: 0,
        },
        /**
         * 是否自动播放
         */
        autoplay: {
            type: Boolean,
            default: true,
        },
        /**
         * 是否循环播放
         */
        loop: {
            type: Boolean,
            default: false,
        },
        /**
         * 是否开启弹幕插槽，默认否
         */
        useSlot: {
            type: Boolean,
            default: false,
        },
        /**
         * 弹幕刷新频率(ms)
         */
        debounce: {
            type: Number,
            default: 100,
        },
        /**
         * 弹幕速度（像素/秒）
         */
        speeds: {
            type: Number,
            default: 200,
        },
        /**
         * 是否开启随机轨道注入弹幕
         */
        randomChannel: {
            type: Boolean,
            default: false,
        },
        /**
         * 弹幕字号（仅文本模式）
         */
        fontSize: {
            type: Number,
            default: 18,
        },
        /**
         * 弹幕垂直间距
         */
        top: {
            type: Number,
            default: 4,
        },
        /**
         * 弹幕水平间距
         */
        right: {
            type: Number,
            default: 0,
        },
        /**
         * 是否开启悬浮暂停
         */
        isSuspend: {
            type: Boolean,
            default: false,
        },
        /**
         * 弹幕额外样式
         */
        extraStyle: {
            type: String,
            default: '',
        },
    },
    emits: ['list-end', 'play-end', 'update:danmus'],
    setup(props, { emit, slots }) {
        // 容器
        let container = ref(document.createElement('div'));
        let dmContainer = ref(document.createElement('div'));
        const containerWidth = ref(0);
        const containerHeight = ref(0);
        // 变量
        let timer = 0;
        const calcChannels = ref(0);
        const danmuHeight = ref(0);
        const index = ref(0);
        const hidden = ref(false);
        const paused = ref(false);
        const danChannel = ref({});
        const danmuList = useModelWrapper(props, emit, 'danmus');
        const danmaku = reactive({
            channels: computed(() => props.channels || calcChannels.value),
            autoplay: computed(() => props.autoplay),
            loop: computed(() => props.loop),
            useSlot: computed(() => props.useSlot),
            debounce: computed(() => props.debounce),
            randomChannel: computed(() => props.randomChannel),
        });
        const danmu = reactive({
            height: computed(() => danmuHeight.value),
            fontSize: computed(() => props.fontSize),
            speeds: computed(() => props.speeds),
            top: computed(() => props.top),
            right: computed(() => props.right),
        });
        onMounted(() => {
            init();
        });
        onBeforeUnmount(() => {
            clear();
        });
        function init() {
            initCore();
            props.isSuspend && initSuspendEvents();
            if (danmaku.autoplay) {
                play();
            }
        }
        function initCore() {
            containerWidth.value = container.value.offsetWidth;
            containerHeight.value = container.value.offsetHeight;
        }
        function play() {
            paused.value = false;
            if (!timer) {
                timer = setInterval(() => draw(), danmaku.debounce);
            }
        }
        /**
         * 绘制弹幕
         */
        function draw() {
            if (!paused.value && danmuList.value.length) {
                if (index.value > danmuList.value.length - 1) {
                    const screenDanmus = dmContainer.value.children.length;
                    if (danmaku.loop) {
                        if (screenDanmus < index.value) {
                            // 一轮弹幕插入完毕
                            emit('list-end');
                            index.value = 0;
                        }
                        insert();
                    }
                }
                else {
                    insert();
                }
            }
        }
        /**
         * 插入弹幕（也暴露到外部，允许外部直接执行绘制弹幕方法）
         * @param {Object} dm 外部定义的弹幕
         */
        function insert(dm) {
            const _index = danmaku.loop ? index.value % danmuList.value.length : index.value;
            const _danmu = dm || danmuList.value[_index];
            let el = document.createElement(`div`);
            if (danmaku.useSlot) {
                el = getSlotComponent(_danmu, _index).$el;
            }
            else {
                el.innerHTML = _danmu;
                el.setAttribute('style', props.extraStyle);
                el.style.fontSize = `${danmu.fontSize}px`;
                el.style.lineHeight = `${danmu.fontSize}px`;
            }
            el.classList.add('dm');
            dmContainer.value.appendChild(el);
            el.style.opacity = '0';
            nextTick(() => {
                if (!danmu.height) {
                    danmuHeight.value = el.offsetHeight;
                }
                // 如果没有设置轨道数，则在获取到所有高度后计算出最大轨道数
                if (!danmaku.channels) {
                    calcChannels.value = Math.floor(containerHeight.value / (danmu.height + danmu.top));
                }
                let channelIndex = getChannelIndex(el);
                if (channelIndex >= 0) {
                    const width = el.offsetWidth;
                    const height = danmu.height;
                    el.classList.add('move');
                    el.dataset.index = `${_index}`;
                    el.style.opacity = '1';
                    el.style.top = channelIndex * (height + danmu.top) + 'px';
                    el.style.width = width + danmu.right + 'px';
                    el.style.setProperty('--dm-scroll-width', `-${containerWidth.value + (width * 2)}px`);
                    el.style.left = `${containerWidth.value}px`;
                    el.style.animationDuration = `${containerWidth.value / danmu.speeds}s`;
                    el.addEventListener('animationend', () => {
                        if (Number(el.dataset.index) === danmuList.value.length - 1 && !danmaku.loop) {
                            emit('play-end', el.dataset.index);
                        }
                        dmContainer.value && dmContainer.value.removeChild(el);
                    });
                    index.value++;
                }
                else {
                    dmContainer.value.removeChild(el);
                }
            });
        }
        function getSlotComponent(_danmu, _index) {
            const DmComponent = createApp({
                render() {
                    return h('div', {}, [
                        slots.dm &&
                            slots.dm({
                                danmu: _danmu,
                                index: _index,
                            }),
                    ]);
                },
            });
            const ele = DmComponent.mount(document.createElement('div'));
            return ele;
        }
        function getChannelIndex(el) {
            let _channels = [...Array(danmaku.channels).keys()];
            if (danmaku.randomChannel) {
                _channels = _channels.sort(() => 0.5 - Math.random());
            }
            for (let i of _channels) {
                const items = danChannel.value[i];
                if (items && items.length) {
                    for (let j = 0; j < items.length; j++) {
                        const danRight = getDanRight(items[j]) - 10;
                        // 安全距离判断
                        if (danRight <= (el.offsetWidth - items[j].offsetWidth) * 0.88 || danRight <= 0) {
                            break;
                        }
                        if (j === items.length - 1) {
                            danChannel.value[i].push(el);
                            el.addEventListener('animationend', () => danChannel.value[i].splice(0, 1));
                            return i % danmaku.channels;
                        }
                    }
                }
                else {
                    danChannel.value[i] = [el];
                    el.addEventListener('animationend', () => danChannel.value[i].splice(0, 1));
                    return i % danmaku.channels;
                }
            }
            return -1;
        }
        /**
         * 获取弹幕右侧到屏幕右侧的距离
         */
        function getDanRight(el) {
            const eleWidth = el.offsetWidth || parseInt(el.style.width);
            const eleRight = el.getBoundingClientRect().right || dmContainer.value.getBoundingClientRect().right + eleWidth;
            return dmContainer.value.getBoundingClientRect().right - eleRight;
        }
        function clearTimer() {
            clearInterval(timer);
            timer = 0;
        }
        function initSuspendEvents() {
            let suspendDanmus = [];
            dmContainer.value.addEventListener('mousemove', (e) => {
                let target = e.target;
                if (!target.className.includes('dm')) {
                    target = target.closest('.dm') || target;
                }
                if (!target.className.includes('dm'))
                    return;
                target.classList.add('pause');
                suspendDanmus.push(target);
            });
            dmContainer.value.addEventListener('mouseout', (e) => {
                let target = e.target;
                if (!target.className.includes('dm')) {
                    target = target.closest('.dm') || target;
                }
                if (!target.className.includes('dm'))
                    return;
                target.classList.remove('pause');
                suspendDanmus.forEach((item) => {
                    item.classList.remove('pause');
                });
                suspendDanmus = [];
            });
        }
        /**
         * 清空弹幕
         */
        function clear() {
            clearTimer();
            index.value = 0;
        }
        /**
         * 重置弹幕
         */
        function reset() {
            danmuHeight.value = 0;
            init();
        }
        /**
         * 停止弹幕
         */
        function stop() {
            danChannel.value = {};
            dmContainer.value.innerHTML = '';
            paused.value = true;
            hidden.value = false;
            clear();
        }
        /**
         * 暂停弹幕
         */
        function pause() {
            paused.value = true;
        }
        /**
         * 添加弹幕（插入到当前播放的弹幕位置）
         */
        function add(danmu) {
            if (index.value === danmuList.value.length) {
                // 如果当前弹幕已经播放完了，那么仍然走 push
                danmuList.value.push(danmu);
                return danmuList.value.length - 1;
            }
            else {
                const _index = index.value % danmuList.value.length;
                danmuList.value.splice(_index, 0, danmu);
                return _index + 1;
            }
        }
        /**
         * 添加弹幕（插入到弹幕末尾）
         */
        function push(danmu) {
            danmuList.value.push(danmu);
            return danmuList.value.length - 1;
        }
        /**
         * 获取播放状态
         */
        function getPlayState() {
            return !paused.value;
        }
        /**
         * 显示弹幕
         */
        function show() {
            hidden.value = false;
        }
        /**
         * 隐藏弹幕
         */
        function hide() {
            hidden.value = true;
        }
        function resize() {
            initCore();
            const items = dmContainer.value.getElementsByClassName('dm');
            for (let i = 0; i < items.length; i++) {
                const el = items[i];
                el.style.setProperty('--dm-scroll-width', `-${containerWidth.value + (el.offsetWidth * 2)}px`);
                el.style.left = `${containerWidth.value}px`;
                el.style.animationDuration = `${containerWidth.value / danmu.speeds}s`;
            }
        }
        return {
            // element
            container,
            dmContainer,
            // variable
            hidden,
            paused,
            danmuList,
            // function
            getPlayState,
            resize,
            play,
            pause,
            stop,
            show,
            hide,
            reset,
            add,
            push,
            insert,
        };
    },
});

const _hoisted_1 = {
  ref: "container",
  class: "vue-danmaku"
};

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createElementBlock("div", _hoisted_1, [
    createElementVNode("div", {
      ref: "dmContainer",
      class: normalizeClass(['danmus', { show: !_ctx.hidden }, { paused: _ctx.paused }])
    }, null, 2 /* CLASS */),
    renderSlot(_ctx.$slots, "default")
  ], 512 /* NEED_PATCH */))
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".vue-danmaku {\n  position: relative;\n  overflow: hidden;\n}\n.vue-danmaku .danmus {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  opacity: 0;\n  -webkit-transition: all 0.3s;\n  transition: all 0.3s;\n}\n.vue-danmaku .danmus.show {\n  opacity: 1;\n}\n.vue-danmaku .danmus.paused .dm.move {\n  animation-play-state: paused;\n}\n.vue-danmaku .danmus .dm {\n  position: absolute;\n  font-size: 20px;\n  color: #ddd;\n  white-space: pre;\n  transform: translateX(0);\n  transform-style: preserve-3d;\n}\n.vue-danmaku .danmus .dm.move {\n  will-change: transform;\n  animation-name: moveLeft;\n  animation-timing-function: linear;\n  animation-play-state: running;\n}\n.vue-danmaku .danmus .dm.pause {\n  animation-play-state: paused;\n  z-index: 10;\n}\n@keyframes moveLeft {\n  from {\n    transform: translateX(0);\n  }\n  to {\n    transform: translateX(var(--dm-scroll-width));\n  }\n}\n@-webkit-keyframes moveLeft {\n  from {\n    -webkit-transform: translateX(0);\n  }\n  to {\n    -webkit-transform: translateX(var(--dm-scroll-width));\n  }\n}";
styleInject(css_248z);

script.render = render;
script.__file = "src/lib/Danmaku.vue";

export { script as default };
