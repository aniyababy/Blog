{
  "version": 3,
  "sources": ["../../markdown-it-katex-external/index.js"],
  "sourcesContent": ["/**\n * @Author: chenhuachao <chc>\n * @Date:   2017-11-26T15:57:48+08:00\n * @Email:  chenhuachaoxyz@gmail.com\n * @Filename: index.js\n * @Last modified by:   chc\n * @Last modified time: 2017-11-26T16:00:49+08:00\n * @License: MIT\n * @Copyright: 2017\n */\n/**\n * This is fork from https://github.com/waylonflinn/markdown-it-katex and support for external_link.\n */\n/* Process inline math */\n/*\nLike markdown-it-simplemath, this is a stripped down, simplified version of:\nhttps://github.com/runarberg/markdown-it-math\n\nIt differs in that it takes (a subset of) LaTeX as input and relies on KaTeX\nfor rendering output.\n*/\n\n/*jslint node: true */\n'use strict';\n\nvar katex = null;\n\n// Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\nfunction isValidDelim(state, pos) {\n    var prevChar, nextChar,\n        max = state.posMax,\n        can_open = true,\n        can_close = true;\n\n    prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n    nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;\n\n    // Check non-whitespace conditions for opening and closing, and\n    // check that closing delimeter isn't followed by a number\n    if (prevChar === 0x20/* \" \" */ || prevChar === 0x09/* \\t */ ||\n            (nextChar >= 0x30/* \"0\" */ && nextChar <= 0x39/* \"9\" */)) {\n        can_close = false;\n    }\n    if (nextChar === 0x20/* \" \" */ || nextChar === 0x09/* \\t */) {\n        can_open = false;\n    }\n\n    return {\n        can_open: can_open,\n        can_close: can_close\n    };\n}\n\nfunction math_inline(state, silent) {\n    if (!katex && window.katex) katex = window.katex;\n    if (!katex) return false;\n    var start, match, token, res, pos, esc_count;\n\n    if (state.src[state.pos] !== \"$\") { return false; }\n\n    res = isValidDelim(state, state.pos);\n    if (!res.can_open) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos += 1;\n        return true;\n    }\n\n    // First check for and bypass all properly escaped delimieters\n    // This loop will assume that the first leading backtick can not\n    // be the first character in state.src, which is known since\n    // we have found an opening delimieter already.\n    start = state.pos + 1;\n    match = start;\n    while ( (match = state.src.indexOf(\"$\", match)) !== -1) {\n        // Found potential $, look for escapes, pos will point to\n        // first non escape when complete\n        pos = match - 1;\n        while (state.src[pos] === \"\\\\\") { pos -= 1; }\n\n        // Even number of escapes, potential closing delimiter found\n        if ( ((match - pos) % 2) == 1 ) { break; }\n        match += 1;\n    }\n\n    // No closing delimter found.  Consume $ and continue.\n    if (match === -1) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n        if (!silent) { state.pending += \"$$\"; }\n        state.pos = start + 1;\n        return true;\n    }\n\n    // Check for valid closing delimiter\n    res = isValidDelim(state, match);\n    if (!res.can_close) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    if (!silent) {\n        token         = state.push('math_inline', 'math', 0);\n        token.markup  = \"$\";\n        token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n    return true;\n}\n\nfunction math_block(state, start, end, silent){\n    if (!katex && window.katex) katex = window.katex;\n    if (!katex) return false;\n    var firstLine, lastLine, next, lastPos, found = false, token,\n        pos = state.bMarks[start] + state.tShift[start],\n        max = state.eMarks[start]\n\n    if(pos + 2 > max){ return false; }\n    if(state.src.slice(pos,pos+2)!=='$$'){ return false; }\n\n    pos += 2;\n    firstLine = state.src.slice(pos,max);\n\n    if(silent){ return true; }\n    if(firstLine.trim().slice(-2)==='$$'){\n        // Single line expression\n        firstLine = firstLine.trim().slice(0, -2);\n        found = true;\n    }\n\n    for(next = start; !found; ){\n\n        next++;\n\n        if(next >= end){ break; }\n\n        pos = state.bMarks[next]+state.tShift[next];\n        max = state.eMarks[next];\n\n        if(pos < max && state.tShift[next] < state.blkIndent){\n            // non-empty line with negative indent should stop the list:\n            break;\n        }\n\n        if(state.src.slice(pos,max).trim().slice(-2)==='$$'){\n            lastPos = state.src.slice(0,max).lastIndexOf('$$');\n            lastLine = state.src.slice(pos,lastPos);\n            found = true;\n        }\n\n    }\n\n    state.line = next + 1;\n\n    token = state.push('math_block', 'math', 0);\n    token.block = true;\n    token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '')\n    + state.getLines(start + 1, next, state.tShift[start], true)\n    + (lastLine && lastLine.trim() ? lastLine : '');\n    token.map = [ start, state.line ];\n    token.markup = '$$';\n    return true;\n}\n\nmodule.exports = function math_plugin(md, options) {\n    // Default options\n\n    options = options || {};\n\n    // set KaTeX as the renderer for markdown-it-simplemath\n    var katexInline = function(latex){\n        if(!katex && window.katex) katex = window.katex;\n        options.displayMode = false;\n        try{\n            return katex.renderToString(latex, options);\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return latex;\n        }\n    };\n\n    var inlineRenderer = function(tokens, idx){\n        return katexInline(tokens[idx].content);\n    };\n\n    var katexBlock = function(latex){\n        if(!katex && window.katex) katex = window.katex;\n        options.displayMode = true;\n        try{\n            return \"<p>\" + katex.renderToString(latex, options) + \"</p>\";\n        }\n        catch(error){\n            if(options.throwOnError){ console.log(error); }\n            return latex;\n        }\n    }\n\n    var blockRenderer = function(tokens, idx){\n        return  katexBlock(tokens[idx].content) + '\\n';\n    }\n\n    md.inline.ruler.after('escape', 'math_inline', math_inline);\n    md.block.ruler.after('blockquote', 'math_block', math_block, {\n        alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n    });\n    md.renderer.rules.math_inline = inlineRenderer;\n    md.renderer.rules.math_block = blockRenderer;\n};\n"],
  "mappings": "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",
  "names": []
}
